<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FindTModelByNameQuery.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jUDDI Core Services</a> &gt; <a href="index.source.html" class="el_package">org.apache.juddi.query</a> &gt; <span class="el_source">FindTModelByNameQuery.java</span></div><h1>FindTModelByNameQuery.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2001-2008 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.apache.juddi.query;

import java.util.List;

import javax.persistence.EntityManager;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.juddi.query.util.DynamicQuery;
import org.apache.juddi.query.util.FindQualifiers;
import org.uddi.api_v3.Name;

/**
 * 
 * Returns the list of tmodel keys possessing the passed Name argument.
 * Output is restricted by list of tModel keys passed in.  If null, all tModels are searched.
 * Output is produced by building the appropriate JPA query based on input and find qualifiers.
 * 
 * From specification:
 * &quot;This string value  represents the name of the tModel elements to be found.  Since tModel data only has a single 
 * name, only a single name may be passed.  The argument must match exactly since &quot;exactMatch&quot; is the default behavior, 
 * but if the &quot;approximateMatch&quot; findQualifier is used together with the appropriate wildcard character, then matching 
 * is done according to wildcard rules. See Section 5.1.6 About Wildcards for additional information.  The name MAY be 
 * marked with an xml:lang adornment.  If a language markup is specified, the search results report a match only on those 
 * entries that match both the name value and language criteria. The match on language is a leftmost case-insensitive 
 * comparison of the characters supplied. This allows one to find all tModels whose name begins with an &quot;A&quot; and are expressed 
 * in any dialect of French, for example.  Values which can be passed in the language criteria adornment MUST obey the rules 
 * governing the xml:lang data type as defined in Section 3.3.2.3 name.&quot;
 * 
 * @author &lt;a href=&quot;mailto:jfaath@apache.org&quot;&gt;Jeff Faath&lt;/a&gt;
 */
<span class="nc" id="L49">public class FindTModelByNameQuery extends TModelQuery {</span>

	@SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L52">	private static Log log = LogFactory.getLog(FindTModelByNameQuery.class);</span>

	public static List&lt;Object&gt; select(EntityManager em, FindQualifiers fq, Name name, List&lt;Object&gt; keysIn, DynamicQuery.Parameter... restrictions) {
		// If keysIn is not null and empty, then search is over.
<span class="fc bfc" id="L56" title="All 4 branches covered.">		if ((keysIn != null) &amp;&amp; (keysIn.isEmpty()))</span>
<span class="fc" id="L57">			return keysIn;</span>
		
<span class="fc bfc" id="L59" title="All 2 branches covered.">		if (name == null)</span>
<span class="fc" id="L60">			return keysIn;</span>
		
<span class="fc" id="L62">		DynamicQuery dynamicQry = new DynamicQuery(selectSQL);</span>
<span class="fc" id="L63">		appendConditions(dynamicQry, fq, name);</span>
		// Since this is a tModel, don't need to search the lazily deleted ones.
<span class="fc" id="L65">		dynamicQry.AND().pad().appendGroupedAnd(new DynamicQuery.Parameter(ENTITY_ALIAS + &quot;.deleted&quot;, false, DynamicQuery.PREDICATE_EQUALS));</span>
<span class="pc bpc" id="L66" title="2 of 4 branches missed.">		if (restrictions != null &amp;&amp; restrictions.length &gt; 0)</span>
<span class="nc" id="L67">			dynamicQry.AND().pad().appendGroupedAnd(restrictions);</span>
		
<span class="fc" id="L69">		return getQueryResult(em, dynamicQry, keysIn, ENTITY_ALIAS + &quot;.&quot; + KEY_NAME);</span>
	}
	
	public static void appendConditions(DynamicQuery qry, FindQualifiers fq, Name name) {
<span class="fc" id="L73">		String namePredicate = DynamicQuery.PREDICATE_EQUALS;</span>
<span class="pc bpc" id="L74" title="2 of 4 branches missed.">		if (fq!=null &amp;&amp; fq.isApproximateMatch()) {</span>
<span class="fc" id="L75">			namePredicate = DynamicQuery.PREDICATE_LIKE;</span>
		}

<span class="fc" id="L78">		qry.WHERE().pad().openParen().pad();</span>

<span class="fc" id="L80">		String nameTerm = ENTITY_ALIAS + &quot;.name&quot;;</span>
<span class="fc" id="L81">		String nameValue = name.getValue();</span>
<span class="pc bpc" id="L82" title="1 of 4 branches missed.">		if (fq!=null &amp;&amp; fq.isCaseInsensitiveMatch()) {</span>
<span class="fc" id="L83">			nameTerm = &quot;upper(&quot; + ENTITY_ALIAS + &quot;.name)&quot;;</span>
<span class="fc" id="L84">			nameValue = name.getValue().toUpperCase();</span>
		}
		// JUDDI-235: wildcards are provided by user (only commenting in case a new interpretation arises)
		//if (fq.isApproximateMatch())
		//	nameValue = nameValue.endsWith(DynamicQuery.WILDCARD)?nameValue:nameValue + DynamicQuery.WILDCARD;
		
<span class="pc bpc" id="L90" title="1 of 4 branches missed.">		if (name.getLang() == null || name.getLang().length() == 0 ) {</span>
<span class="fc" id="L91">			qry.appendGroupedAnd(new DynamicQuery.Parameter(nameTerm, nameValue, namePredicate));</span>
		}
		else {
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">			String langValue = name.getLang().endsWith(DynamicQuery.WILDCARD)?name.getLang().toUpperCase():name.getLang().toUpperCase() + DynamicQuery.WILDCARD;</span>
<span class="fc" id="L95">			qry.appendGroupedAnd(new DynamicQuery.Parameter(nameTerm, nameValue, namePredicate), </span>
								 new DynamicQuery.Parameter(&quot;upper(&quot; + ENTITY_ALIAS + &quot;.langCode)&quot;, langValue, DynamicQuery.PREDICATE_LIKE));
		}

<span class="fc" id="L99">		qry.closeParen().pad();</span>
<span class="pc bpc" id="L100" title="2 of 4 branches missed.">		if (fq!=null &amp;&amp; fq.isSignaturePresent()) {</span>
<span class="nc" id="L101">			qry.AND().pad().openParen().pad().append(TModelQuery.SIGNATURE_PRESENT).pad().closeParen().pad();</span>
		}
<span class="fc" id="L103">	}</span>
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>